{
    "docs": [
        {
            "location": "/",
            "text": "zend-crypt\n\n\n\n\n\n\nZend\\Crypt\n provides support of some cryptographic tools.\nSome of the available features are:\n\n\n\n\nencrypt-then-authenticate using symmetric ciphers (the authentication step\n  is provided using HMAC);\n\n\nencrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);\n\n\nencrypt/decrypt using hybrid mode (OpenPGP like);\n\n\ngenerate digital sign using public key algorithm (e.g. RSA algorithm);\n\n\nkey exchange using the Diffie-Hellman method;\n\n\nkey derivation function (e.g. using PBKDF2 algorithm);\n\n\nsecure password hash (e.g. using Bcrypt algorithm);\n\n\ngenerate Hash values;\n\n\ngenerate HMAC values;\n\n\n\n\nThe main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-crypt/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-crypt",
            "title": "zend-crypt"
        },
        {
            "location": "/#zend-crypt",
            "text": "Zend\\Crypt  provides support of some cryptographic tools.\nSome of the available features are:   encrypt-then-authenticate using symmetric ciphers (the authentication step\n  is provided using HMAC);  encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);  encrypt/decrypt using hybrid mode (OpenPGP like);  generate digital sign using public key algorithm (e.g. RSA algorithm);  key exchange using the Diffie-Hellman method;  key derivation function (e.g. using PBKDF2 algorithm);  secure password hash (e.g. using Bcrypt algorithm);  generate Hash values;  generate HMAC values;   The main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP.   File issues at https://github.com/zendframework/zend-crypt/issues  Documentation is at https://docs.zendframework.com/zend-crypt",
            "title": "zend-crypt"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-crypt provides support for several cryptographic tools, with the following\nfeatures:\n\n\n\n\nencrypt-then-authenticate using symmetric ciphers (the authentication step is\n  provided using HMAC);\n\n\nencrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);\n\n\ngenerate digital signature using public key algorithm (e.g. RSA algorithm);\n\n\nkey exchange using the Diffie-Hellman method;\n\n\nkey derivation function (e.g. using PBKDF2 algorithm);\n\n\nsecure password hash (e.g. using bcrypt algorithm);\n\n\ngenerate hash values; and\n\n\ngenerate HMAC values.\n\n\n\n\nThe main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP. Because the use of cryptography is often\ncomplex, we recommend using the component only if you have background on this\ntopic. For an introduction to cryptography, we suggest the following references:\n\n\n\n\nDan Boneh, \n\"Cryptography course\"\n,\n  Stanford University, Coursera; free online course\n\n\nN.Ferguson, B.Schneier, and T.Kohno, \n\"Cryptography Engineering\"\n,\n  John Wiley & Sons (2010)\n\n\nB.Schneier \n\"Applied Cryptography\"\n,\n  John Wiley & Sons (1996)",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-crypt provides support for several cryptographic tools, with the following\nfeatures:   encrypt-then-authenticate using symmetric ciphers (the authentication step is\n  provided using HMAC);  encrypt/decrypt using symmetric and public key algorithm (e.g. RSA algorithm);  generate digital signature using public key algorithm (e.g. RSA algorithm);  key exchange using the Diffie-Hellman method;  key derivation function (e.g. using PBKDF2 algorithm);  secure password hash (e.g. using bcrypt algorithm);  generate hash values; and  generate HMAC values.   The main scope of this component is to offer an easy and secure way to protect\nand authenticate sensitive data in PHP. Because the use of cryptography is often\ncomplex, we recommend using the component only if you have background on this\ntopic. For an introduction to cryptography, we suggest the following references:   Dan Boneh,  \"Cryptography course\" ,\n  Stanford University, Coursera; free online course  N.Ferguson, B.Schneier, and T.Kohno,  \"Cryptography Engineering\" ,\n  John Wiley & Sons (2010)  B.Schneier  \"Applied Cryptography\" ,\n  John Wiley & Sons (1996)",
            "title": "Introduction"
        },
        {
            "location": "/block-cipher/",
            "text": "Encrypt/decrypt using block ciphers\n\n\nZend\\Crypt\\BlockCipher\n implements encrypt-then-authenticate mode using\n\nHMAC\n to provide authentication.\n\n\nThe symmetric cipher can be chosen with a specific adapter that implements\n\nZend\\Crypt\\Symmetric\\SymmetricInterface\n. We support the symmmetric encryption\nalgorithms offered by \nOpenSSL\n and\n\nMcrypt\n extensions.\n\n\nIn the following code, we detail an example of using the \nBlockCipher\n class to\nencrypt-then-authenticate a string using the\n\nAES-256\n block cipher\nand the HMAC algorithm (using the \nSHA-256\n\nhash function).\n\n\n\n\nMcrypt\n\n\nThe Mcrypt extension is based on the libmcrypt library. Unfortunately, at the\ntime of writing, the project is dead, having been unmaintained for around 8\nyears, with the last release (version 2.5.8) having occurred in February 2007.\n\n\nStarting with PHP 7.1, the Mcrypt extension will be\n\nconsidered deprecated\n.\nFor these reasons, \nwe strongly suggest using only the Openssl adapter\n.\n\n\nStarting with zend-crypt 3.0, the Openssl adapter is the default (for example,\nby \nZend\\Crypt\\FileCipher\n), and all examples now only demonstrate that\nadapter.\n\n\n\n\nuse Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory('openssl', array('algo' => 'aes'));\n$blockCipher->setKey('encryption key');\n$result = $blockCipher->encrypt('this is a secret message');\necho \"Encrypted text: $result\\n\";\n\n\n\nThe \nBlockCipher\n instance is initialized using a factory method with the name\nof the cipher adapter to use (e.g., \nopenssl\n) and the parameters to pass to the adapter\n(the AES algorithm). In order to encrypt a string, we need to specify an\nencryption key, which we do via the \nsetKey()\n method. Encryption is performed\nwith the \nencrypt()\n method.\n\n\nThe output of encryption is a string, encoded in Base64 (default), containing\nthe HMAC value, the IV vector, and the encrypted text. The encryption mode used\nis \nCBC\n\n(with a random \nIV\n by\ndefault), with the default HMAC hash algorithm of SHA256.  The Openssl adapter\nencrypts using the \nPKCS#7 padding\n\nmechanism by default. You can specify a different padding method using a special\nadapter (\nZend\\Crypt\\Symmetric\\Padding\n). The encryption and authentication keys\nused by \nBlockCipher\n are generated with the \nPBKDF2\n\nalgorithm, used as the key derivation function from the user's key specified\nusing the \nsetKey()\n method.\n\n\n\n\nKey size\n\n\nBlockCipher always attempts to use the longest key size for the specified\ncipher. For instance, for the AES algorithm it uses 256 bits, and for the\n\nBlowfish\n algorithm it\nuses 448 bits.\n\n\n\n\nYou can change all the default settings by passing the values to the factory\nparameters. For instance, if you want to use the Blowfish algorithm, with the\nCFB mode and the HMAC SHA512 hash function, initialize the class as follows:\n\n\nuse Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' => 'blowfish',\n        'mode' => 'cfb',\n        'hash' => 'sha512'\n    ]\n);\n\n\n\n\n\nRecommendation\n\n\nIf you are not familiar with symmetric encryption techniques, we strongly\nsuggest using the default values of the \nBlockCipher\n class. The default\nvalues are: AES algorithm, CBC mode, HMAC with SHA256, PKCS#7 padding.\n\n\n\n\nTo decrypt a string we can use the \ndecrypt()\n method. In order to successfully\ndecrypt a string, we must configure the \nBlockCipher\n with the same parameters\nused during encryption.\n\n\nWe can also initialize the \nBlockCipher\n manually without using the factory method;\nwe can inject the symmetric cipher adapter directly via the constructor.\nFor instance, we can rewrite the previous example as follows:\n\n\nuse Zend\\Crypt\\BlockCipher;\nuse Zend\\Crypt\\Symmetric\\Openssl;\n\n$blockCipher = new BlockCipher(new Openssl(['algo' => 'aes']));\n$blockCipher->setKey('encryption key');\n$result = $blockCipher->encrypt('this is a secret message');\necho \"Encrypted text: $result \\n\";\n\n\n\nUsing GCM or CCM mode from PHP 7.1+\n\n\nIf you are using PHP 7.1+ you can choose the GCM or CCM mode for authenticated\nencryption with OpenSSL. These modes provide authenticated encryption by itself,\nwithout the usage of HMAC as described in the previous section.\n\n\nGCM is \nGalois/Counter Mode\n\nand CCM is \nCounter with CBC-MAC\n.\nFor more information on the usage of this encryption modes in PHP we suggest to\nread \nthis blog post\n.\n\n\nIf you want to use the GCM or CCM mode with \nBlockCipher\n you can just specify\nthe mode in the factory. For instance, the following is an example of\n\naes-256-gcm\n encryption with OpenSSL:\n\n\nuse Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' => 'aes',\n        'mode' => 'gcm'\n    ]\n);\n\n\n\nAnd below is an example demonstrating the factory for \naes-256-ccm\n algorithm:\n\n\nuse Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' => 'aes',\n        'mode' => 'ccm'\n    ]\n);\n\n\n\n\n\nRecommendation\n\n\nGCM mode is about 3x faster than CCM\n, we recommend using GCM unless\nyou have requirements that dictate CCM.",
            "title": "Block Ciphers"
        },
        {
            "location": "/block-cipher/#encryptdecrypt-using-block-ciphers",
            "text": "Zend\\Crypt\\BlockCipher  implements encrypt-then-authenticate mode using HMAC  to provide authentication.  The symmetric cipher can be chosen with a specific adapter that implements Zend\\Crypt\\Symmetric\\SymmetricInterface . We support the symmmetric encryption\nalgorithms offered by  OpenSSL  and Mcrypt  extensions.  In the following code, we detail an example of using the  BlockCipher  class to\nencrypt-then-authenticate a string using the AES-256  block cipher\nand the HMAC algorithm (using the  SHA-256 \nhash function).",
            "title": "Encrypt/decrypt using block ciphers"
        },
        {
            "location": "/block-cipher/#mcrypt",
            "text": "The Mcrypt extension is based on the libmcrypt library. Unfortunately, at the\ntime of writing, the project is dead, having been unmaintained for around 8\nyears, with the last release (version 2.5.8) having occurred in February 2007.  Starting with PHP 7.1, the Mcrypt extension will be considered deprecated .\nFor these reasons,  we strongly suggest using only the Openssl adapter .  Starting with zend-crypt 3.0, the Openssl adapter is the default (for example,\nby  Zend\\Crypt\\FileCipher ), and all examples now only demonstrate that\nadapter.   use Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory('openssl', array('algo' => 'aes'));\n$blockCipher->setKey('encryption key');\n$result = $blockCipher->encrypt('this is a secret message');\necho \"Encrypted text: $result\\n\";  The  BlockCipher  instance is initialized using a factory method with the name\nof the cipher adapter to use (e.g.,  openssl ) and the parameters to pass to the adapter\n(the AES algorithm). In order to encrypt a string, we need to specify an\nencryption key, which we do via the  setKey()  method. Encryption is performed\nwith the  encrypt()  method.  The output of encryption is a string, encoded in Base64 (default), containing\nthe HMAC value, the IV vector, and the encrypted text. The encryption mode used\nis  CBC \n(with a random  IV  by\ndefault), with the default HMAC hash algorithm of SHA256.  The Openssl adapter\nencrypts using the  PKCS#7 padding \nmechanism by default. You can specify a different padding method using a special\nadapter ( Zend\\Crypt\\Symmetric\\Padding ). The encryption and authentication keys\nused by  BlockCipher  are generated with the  PBKDF2 \nalgorithm, used as the key derivation function from the user's key specified\nusing the  setKey()  method.",
            "title": "Mcrypt"
        },
        {
            "location": "/block-cipher/#key-size",
            "text": "BlockCipher always attempts to use the longest key size for the specified\ncipher. For instance, for the AES algorithm it uses 256 bits, and for the Blowfish  algorithm it\nuses 448 bits.   You can change all the default settings by passing the values to the factory\nparameters. For instance, if you want to use the Blowfish algorithm, with the\nCFB mode and the HMAC SHA512 hash function, initialize the class as follows:  use Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' => 'blowfish',\n        'mode' => 'cfb',\n        'hash' => 'sha512'\n    ]\n);",
            "title": "Key size"
        },
        {
            "location": "/block-cipher/#recommendation",
            "text": "If you are not familiar with symmetric encryption techniques, we strongly\nsuggest using the default values of the  BlockCipher  class. The default\nvalues are: AES algorithm, CBC mode, HMAC with SHA256, PKCS#7 padding.   To decrypt a string we can use the  decrypt()  method. In order to successfully\ndecrypt a string, we must configure the  BlockCipher  with the same parameters\nused during encryption.  We can also initialize the  BlockCipher  manually without using the factory method;\nwe can inject the symmetric cipher adapter directly via the constructor.\nFor instance, we can rewrite the previous example as follows:  use Zend\\Crypt\\BlockCipher;\nuse Zend\\Crypt\\Symmetric\\Openssl;\n\n$blockCipher = new BlockCipher(new Openssl(['algo' => 'aes']));\n$blockCipher->setKey('encryption key');\n$result = $blockCipher->encrypt('this is a secret message');\necho \"Encrypted text: $result \\n\";",
            "title": "Recommendation"
        },
        {
            "location": "/block-cipher/#using-gcm-or-ccm-mode-from-php-71",
            "text": "If you are using PHP 7.1+ you can choose the GCM or CCM mode for authenticated\nencryption with OpenSSL. These modes provide authenticated encryption by itself,\nwithout the usage of HMAC as described in the previous section.  GCM is  Galois/Counter Mode \nand CCM is  Counter with CBC-MAC .\nFor more information on the usage of this encryption modes in PHP we suggest to\nread  this blog post .  If you want to use the GCM or CCM mode with  BlockCipher  you can just specify\nthe mode in the factory. For instance, the following is an example of aes-256-gcm  encryption with OpenSSL:  use Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' => 'aes',\n        'mode' => 'gcm'\n    ]\n);  And below is an example demonstrating the factory for  aes-256-ccm  algorithm:  use Zend\\Crypt\\BlockCipher;\n\n$blockCipher = BlockCipher::factory(\n    'openssl',\n    [\n        'algo' => 'aes',\n        'mode' => 'ccm'\n    ]\n);",
            "title": "Using GCM or CCM mode from PHP 7.1+"
        },
        {
            "location": "/block-cipher/#recommendation_1",
            "text": "GCM mode is about 3x faster than CCM , we recommend using GCM unless\nyou have requirements that dictate CCM.",
            "title": "Recommendation"
        },
        {
            "location": "/files/",
            "text": "Encrypt and decrypt files\n\n\nZend\\Crypt\\FileCipher\n implements file encryption and decryption using a\nsymmetric cipher in\n\nCBC\n\nmode with the encrypt-then-authenticate approach, using\n\nHMAC\n to provide authentication (the same\nsolution used by \nZend\\Crypt\\BlockCipher\n component).\n\n\nEncrypting and decrypting a file is not an easy task, especially with large\nfiles. For instance, in CBC mode you must be sure to handle the\n\nIV\n correctly for each\nblock. For large files, that means that you need to use a buffer and use the\nlast block of the buffer as the new IV for the next encryption step.\n\n\nFileCipher\n uses a \nZend\\Crypt\\Symmetric\n cipher to encrypt and decrypt a file.\nThe default cipher is \nZend\\Crypt\\Symmetric\\Openssl\n.\n\n\nThe usage of this component is very simple; create an instance of \nFileCipher\n,\nspecify the key, and you are ready to encrypt/decrypt any file:\n\n\nuse Zend\\Crypt\\FileCipher;\n\n$fileCipher = new FileCipher;\n$fileCipher->setKey('encryption key');\n\n// encryption\nif ($fileCipher->encrypt('path/to/file_to_encrypt', 'path/to/output')) {\n    echo \"The file has been encrypted successfully\\n\";\n}\n\n// decryption\nif ($fileCipher->decrypt('path/to/file_to_decrypt', 'path/to/output')) {\n    echo \"The file has been decrypted successfully\\n\";\n}\n\n\n\nBy default, \nFileCipher\n uses the \nAES\n\nencryption algorithm (with a 256-bit key) and the \nSHA-256\n\nhash algorithm to authenticate the data using the HMAC function. This component uses the\n\nPBKDF2\n key derivation algorithm to generate the encryption\nkey and the authentication key, for the HMAC, based on the key specified using the method\n\nsetKey()\n.\n\n\nIf you want to change the encryption algorithm, you can use the \nsetCipherAlgorithm()\n function. For\ninstance, you could specify the \nBlowfish\n\nencryption algorithm using \nsetCipherAlgorithm('blowfish')\n. You can retrieve the list of all\nsupported encryption algorithms in your environment using the function\n\ngetCipherSupportedAlgorithms()\n.\n\n\nIf you need to customize the cipher algorithm \u2014 for instance, to change\nthe Padding mode \u2014 you can inject your \nMcrypt\n object in the \nFileCipher\n\nusing the \nsetCipher()\n method. The only parameter of the cipher that you cannot\nchange is the cipher mode, which is hard-coded to CBC.\n\n\n\n\nOutput format\n\n\nThe output of the encryption file is in binary format. We used this format to\nreduce impact on output size. If you encrypt a file using the \nFileCipher\n\ncomponent, you will notice that the output file size is almost the same as the\ninput size, with a few additional bytes to store the HMAC and the IV vector.\nThe format of the output is the concatenation of the HMAC, the IV, and the\nencrypted file contents.",
            "title": "Encrypting Files"
        },
        {
            "location": "/files/#encrypt-and-decrypt-files",
            "text": "Zend\\Crypt\\FileCipher  implements file encryption and decryption using a\nsymmetric cipher in CBC \nmode with the encrypt-then-authenticate approach, using HMAC  to provide authentication (the same\nsolution used by  Zend\\Crypt\\BlockCipher  component).  Encrypting and decrypting a file is not an easy task, especially with large\nfiles. For instance, in CBC mode you must be sure to handle the IV  correctly for each\nblock. For large files, that means that you need to use a buffer and use the\nlast block of the buffer as the new IV for the next encryption step.  FileCipher  uses a  Zend\\Crypt\\Symmetric  cipher to encrypt and decrypt a file.\nThe default cipher is  Zend\\Crypt\\Symmetric\\Openssl .  The usage of this component is very simple; create an instance of  FileCipher ,\nspecify the key, and you are ready to encrypt/decrypt any file:  use Zend\\Crypt\\FileCipher;\n\n$fileCipher = new FileCipher;\n$fileCipher->setKey('encryption key');\n\n// encryption\nif ($fileCipher->encrypt('path/to/file_to_encrypt', 'path/to/output')) {\n    echo \"The file has been encrypted successfully\\n\";\n}\n\n// decryption\nif ($fileCipher->decrypt('path/to/file_to_decrypt', 'path/to/output')) {\n    echo \"The file has been decrypted successfully\\n\";\n}  By default,  FileCipher  uses the  AES \nencryption algorithm (with a 256-bit key) and the  SHA-256 \nhash algorithm to authenticate the data using the HMAC function. This component uses the PBKDF2  key derivation algorithm to generate the encryption\nkey and the authentication key, for the HMAC, based on the key specified using the method setKey() .  If you want to change the encryption algorithm, you can use the  setCipherAlgorithm()  function. For\ninstance, you could specify the  Blowfish \nencryption algorithm using  setCipherAlgorithm('blowfish') . You can retrieve the list of all\nsupported encryption algorithms in your environment using the function getCipherSupportedAlgorithms() .  If you need to customize the cipher algorithm \u2014 for instance, to change\nthe Padding mode \u2014 you can inject your  Mcrypt  object in the  FileCipher \nusing the  setCipher()  method. The only parameter of the cipher that you cannot\nchange is the cipher mode, which is hard-coded to CBC.",
            "title": "Encrypt and decrypt files"
        },
        {
            "location": "/files/#output-format",
            "text": "The output of the encryption file is in binary format. We used this format to\nreduce impact on output size. If you encrypt a file using the  FileCipher \ncomponent, you will notice that the output file size is almost the same as the\ninput size, with a few additional bytes to store the HMAC and the IV vector.\nThe format of the output is the concatenation of the HMAC, the IV, and the\nencrypted file contents.",
            "title": "Output format"
        },
        {
            "location": "/hybrid/",
            "text": "Encrypt and decrypt using hybrid cryptosystem - Since 3.1.0\n\n\nHybrid is an encryption mode that uses symmetric and public key ciphers together.\nThe approach takes advantage of public key cryptography for sharing keys and\nsymmetric encryption speed for encrypting messages.\n\n\nHybrid mode allows you to encrypt a message for one or more receivers, and can\nbe used in multi-user scenarios where you wish to limit decryption to specific\nusers.\n\n\nHow it works\n\n\nSuppose we have two users: \nAlice\n and \nBob\n. \nAlice\n wants to send a message to \nBob\n\nusing a hybrid cryptosystem, she needs to:\n\n\n\n\nObtain \nBob\n's public key;\n\n\nGenerates a random session key (one-time pad);\n\n\nEncrypts message using a symmetric cipher with the previous session key;\n\n\nEncrypts session key using the \nBob\n's public key;\n\n\nSends both the encrypted message and encrypted session key to \nBob\n.\n\n\n\n\nA schema of the encryption is reported in the image below:\n\n\n\n\nTo decrypt the message, \nBob\n needs to:\n\n\n\n\nUses his private key to decrypt the session key;\n\n\nUses this session key to decrypt the message.\n\n\n\n\nExample of usage\n\n\nIn order to use the \nZend\\Crypt\\Hybrid\n component, you need to have a keyring of\npublic and private keys. To encrypt a message, use the following code:\n\n\nuse Zend\\Crypt\\Hybrid;\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n// Generate public and private key\n$rsaOptions = new RsaOptions([\n    'pass_phrase' => 'test'\n]);\n$rsaOptions->generateKeys([\n    'private_key_bits' => 4096\n]);\n$publicKey  = $rsaOptions->getPublicKey();\n$privateKey = $rsaOptions->getPrivateKey();\n\n$hybrid     = new Hybrid();\n$ciphertext = $hybrid->encrypt('message', $publicKey);\n$plaintext  = $hybrid->decrypt($ciphertext, $privateKey);\n\nprintf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\");\n\n\n\nWe generated the keys using the \nZend\\Crypt\\PublicKey\\RsaOptions\n\ncomponent. You can also use a \nPEM\n\nstring for the keys. If you use a string for the private key, you need to pass\nthe pass phrase to use when decrypting, if present, like in the following example:\n\n\nuse Zend\\Crypt\\Hybrid;\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n// Generate public and private key\n$rsaOptions = new RsaOptions([\n    'pass_phrase' => 'test'\n]);\n$rsaOptions->generateKeys([\n    'private_key_bits' => 4096\n]);\n// Strings in PEM format\n$publicKey  = $rsaOptions->getPublicKey()->toString();\n$privateKey = $rsaOptions->getPrivateKey()->toString();\n\n$hybrid     = new Hybrid();\n$ciphertext = $hybrid->encrypt('message', $publicKey);\n$plaintext  = $hybrid->decrypt($ciphertext, $privateKey, 'test'); // pass-phrase\n\nprintf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\");\n\n\n\nThe \nHybrid\n component uses \nZend\\Crypt\\BlockCipher\n for the symmetric\ncipher and \nZend\\Crypt\\Rsa\n for the public-key cipher.\n\n\nEncrypt with multiple keys\n\n\nThe \nZend\\Crypt\\Hybrid\n component can be used to encrypt a message for multiple\nusers, using a keyring of identifiers and public keys. This keyring can be\nspecified using an array of \n[ 'id' => 'publickey' ]\n, where \npublickey\n can be\na string (PEM) or an instance of \nZend\\Crypt\\PublicKey\\Rsa\\PublicKey\n. The \nid\n\ncan be any string, for example, a receipient email address.\n\n\nThe following details encryption using a keyring with 4 keys:\n\n\nuse Zend\\Crypt\\Hybrid;\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n$publicKeys  = [];\n$privateKeys = [];\nfor ($id = 0; $id < 4; $id++) {\n    $rsaOptions = new RsaOptions([\n        'pass_phrase' => \"test-$id\"\n    ]);\n    $rsaOptions->generateKeys([\n        'private_key_bits' => 4096\n    ]);\n    $publicKeys[$id]  = $rsaOptions->getPublicKey();\n    $privateKeys[$id] = $rsaOptions->getPrivateKey();\n}\n\n$hybrid    = new Hybrid();\n$encrypted = $hybrid->encrypt('message', $publicKeys);\nfor ($id = 0; $id < 4; $id++) {\n    $plaintext = $hybrid->decrypt($encrypted, $privateKeys[$id], null, $id);\n    printf($plaintext === 'message' ? \"Success on %d\\n\" : \"Error on %d\\n\", $id);\n}",
            "title": "Hybrid Cryptosystem"
        },
        {
            "location": "/hybrid/#encrypt-and-decrypt-using-hybrid-cryptosystem-since-310",
            "text": "Hybrid is an encryption mode that uses symmetric and public key ciphers together.\nThe approach takes advantage of public key cryptography for sharing keys and\nsymmetric encryption speed for encrypting messages.  Hybrid mode allows you to encrypt a message for one or more receivers, and can\nbe used in multi-user scenarios where you wish to limit decryption to specific\nusers.",
            "title": "Encrypt and decrypt using hybrid cryptosystem - Since 3.1.0"
        },
        {
            "location": "/hybrid/#how-it-works",
            "text": "Suppose we have two users:  Alice  and  Bob .  Alice  wants to send a message to  Bob \nusing a hybrid cryptosystem, she needs to:   Obtain  Bob 's public key;  Generates a random session key (one-time pad);  Encrypts message using a symmetric cipher with the previous session key;  Encrypts session key using the  Bob 's public key;  Sends both the encrypted message and encrypted session key to  Bob .   A schema of the encryption is reported in the image below:   To decrypt the message,  Bob  needs to:   Uses his private key to decrypt the session key;  Uses this session key to decrypt the message.",
            "title": "How it works"
        },
        {
            "location": "/hybrid/#example-of-usage",
            "text": "In order to use the  Zend\\Crypt\\Hybrid  component, you need to have a keyring of\npublic and private keys. To encrypt a message, use the following code:  use Zend\\Crypt\\Hybrid;\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n// Generate public and private key\n$rsaOptions = new RsaOptions([\n    'pass_phrase' => 'test'\n]);\n$rsaOptions->generateKeys([\n    'private_key_bits' => 4096\n]);\n$publicKey  = $rsaOptions->getPublicKey();\n$privateKey = $rsaOptions->getPrivateKey();\n\n$hybrid     = new Hybrid();\n$ciphertext = $hybrid->encrypt('message', $publicKey);\n$plaintext  = $hybrid->decrypt($ciphertext, $privateKey);\n\nprintf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\");  We generated the keys using the  Zend\\Crypt\\PublicKey\\RsaOptions \ncomponent. You can also use a  PEM \nstring for the keys. If you use a string for the private key, you need to pass\nthe pass phrase to use when decrypting, if present, like in the following example:  use Zend\\Crypt\\Hybrid;\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n// Generate public and private key\n$rsaOptions = new RsaOptions([\n    'pass_phrase' => 'test'\n]);\n$rsaOptions->generateKeys([\n    'private_key_bits' => 4096\n]);\n// Strings in PEM format\n$publicKey  = $rsaOptions->getPublicKey()->toString();\n$privateKey = $rsaOptions->getPrivateKey()->toString();\n\n$hybrid     = new Hybrid();\n$ciphertext = $hybrid->encrypt('message', $publicKey);\n$plaintext  = $hybrid->decrypt($ciphertext, $privateKey, 'test'); // pass-phrase\n\nprintf($plaintext === 'message' ? \"Success\\n\" : \"Error\\n\");  The  Hybrid  component uses  Zend\\Crypt\\BlockCipher  for the symmetric\ncipher and  Zend\\Crypt\\Rsa  for the public-key cipher.",
            "title": "Example of usage"
        },
        {
            "location": "/hybrid/#encrypt-with-multiple-keys",
            "text": "The  Zend\\Crypt\\Hybrid  component can be used to encrypt a message for multiple\nusers, using a keyring of identifiers and public keys. This keyring can be\nspecified using an array of  [ 'id' => 'publickey' ] , where  publickey  can be\na string (PEM) or an instance of  Zend\\Crypt\\PublicKey\\Rsa\\PublicKey . The  id \ncan be any string, for example, a receipient email address.  The following details encryption using a keyring with 4 keys:  use Zend\\Crypt\\Hybrid;\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n$publicKeys  = [];\n$privateKeys = [];\nfor ($id = 0; $id < 4; $id++) {\n    $rsaOptions = new RsaOptions([\n        'pass_phrase' => \"test-$id\"\n    ]);\n    $rsaOptions->generateKeys([\n        'private_key_bits' => 4096\n    ]);\n    $publicKeys[$id]  = $rsaOptions->getPublicKey();\n    $privateKeys[$id] = $rsaOptions->getPrivateKey();\n}\n\n$hybrid    = new Hybrid();\n$encrypted = $hybrid->encrypt('message', $publicKeys);\nfor ($id = 0; $id < 4; $id++) {\n    $plaintext = $hybrid->decrypt($encrypted, $privateKeys[$id], null, $id);\n    printf($plaintext === 'message' ? \"Success on %d\\n\" : \"Error on %d\\n\", $id);\n}",
            "title": "Encrypt with multiple keys"
        },
        {
            "location": "/key-derivation/",
            "text": "Key derivation function\n\n\nIn cryptography, a key derivation function (or KDF) derives one or more secret\nkeys from a secret value such as a master key, or known information \u2014 such\nas a password or passphrase \u2014 using a pseudo-random function. For\ninstance, a KDF function can be used to generate encryption or authentication\nkeys from a user password. \nZend\\Crypt\\Key\\Derivation\n implements a key\nderivation function using specific adapters.\n\n\nUser passwords are not really suitable to be used as keys in cryptographic\nalgorithms, since users normally choose keys they can write with a keyboard. These\npasswords use only 6 to 7 bits per character (or less). It is highly recommended\nalways to use a KDF function to transform a user's password in a cryptographic\nkey.\n\n\nThe output of the following key derivation functions is a binary string. If you\nneed to store the value in a database or a different persistent storage, we\nsuggest converting it to Base64 format, using the\n\nbase64_encode()\n function,\nor to hex format, using the\n\nbin2hex()\n function.\n\n\nPbkdf2 adapter\n\n\nPbkdf2\n is a KDF that applies a\npseudorandom function, such as a cryptographic hash, to the input password or\npassphrase along with a salt value and repeats the process many times to produce\na derived key, which can then be used as a cryptographic key in subsequent\noperations. The added computational work makes password cracking much more\ndifficult, and is known as \nkey\nstretching\n.\n\n\nIn the example below we demonstrate typical usage of the \nPbkdf2\n adapter.\n\n\nuse Zend\\Crypt\\Key\\Derivation\\Pbkdf2;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Pbkdf2::calc('sha256', $pass, $salt, 10000, 32);\n\nprintf (\"Original password: %s\\n\", $pass);\nprintf (\"Derived key (hex): %s\\n\", bin2hex($key));\n\n\n\nThe \nPbkdf2\n adapter takes the password (\n$pass\n) and generates a binary key of\n32 bytes. The syntax is \ncalc($hash, $pass, $salt, $iterations, $length)\n where\n\n$hash\n is the name of the hash function to use, \n$pass\n is the password,\n\n$salt\n is a pseudo random value, \n$iterations\n is the number of iterations of\nthe algorithm, and \n$length\n is the size of the key to be generated. We use the\n\nRand::getBytes()\n function from the class \nZend\\Math\\Rand\n to generate a random\nstring of 32 bytes for the salt, using a strong generator (the \ntrue\n value\nmeans the usage of a cryptographically strong generator).\n\n\nThe number of iterations is a very important parameter for the security of the\nalgorithm; bigger values guarantee more security. There is no fixed value for\nthe parameter because the number of iterations depends on CPU power. You should\nalways choose a number of iterations that prevents brute force attacks.\n\n\nSaltedS2k adapter\n\n\nThe \nSaltedS2k\n algorithm uses a hash\nfunction and a salt to generate a key based on a user's password. This algorithm\ndoesn't use a parameter to specify the number of iterations, and for that reason\nit's considered less secure compared to Pbkdf2. We suggest using the SaltedS2k\nalgorithm only if you really need it (for instance, due to hardware\nlimitations).\n\n\nThe following demonstrates usage of the \nSaltedS2k\n adapter to generate a 32\nbyte key.\n\n\nuse Zend\\Crypt\\Key\\Derivation\\SaltedS2k;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = SaltedS2k::calc('sha256', $pass, $salt, 32);\n\nprintf (\"Original password: %s\\n\", $pass);\nprintf (\"Derived key (hex): %s\\n\", bin2hex($key));\n\n\n\nScrypt adapter\n\n\nThe \nscrypt\n algorithm uses the \nSalsa20/8\ncore\n algorithm and Pbkdf2-SHA256 to generate a\nkey based on a user's password. This algorithm has been designed to be more\nsecure against hardware brute-force attacks than alternative functions such as\n\nPbkdf2\n or\n\nbcrypt\n.\n\n\nThe scrypt algorithm is based on the idea of memory-hard algorithms and\nsequential memory-hard functions. A memory-hard algorithm is an algorithm which\nasymptotically uses almost as many memory locations as it uses\noperations\n1\n. A natural way to reduce the advantage\nprovided by an attacker\u2019s ability to construct highly parallel circuits is to\nincrease the size of a single key derivation circuit \u2014 if a circuit is twice as\nlarge, only half as many copies can be placed on a given area of silicon \u2014 while\nstill operating within the resources available to software implementations,\nincluding a powerful CPU and large amounts of RAM.\n\n\n\n\n\"From a test executed on modern (2009) hardware, if 5 seconds are spent\ncomputing a derived key, the cost of a hardware brute-force attack against\nscrypt is roughly 4000 times greater than the cost of a similar attack against\nbcrypt (to find the same password), and 20000 times greater than a similar\nattack against Pbkdf2.\"\n\n\n\u2014 \nColin Percival\n (author of the scrypt algorithm)\n\n\n\n\nThis algorithm uses 4 parameters to generate a key of 32 bytes:\n\n\n\n\nsalt\n, a random string;\n\n\nN\n, the CPU cost;\n\n\nr\n, the memory cost;\n\n\np\n, the parallelization cost.\n\n\n\n\nFollowing is a usage example for the \nScrypt\n adapter:\n\n\nuse Zend\\Crypt\\Key\\Derivation\\Scrypt;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Scrypt::calc($pass, $salt, 2048, 2, 1, 32);\n\nprintf (\"Original password: %s\\n\", $pass);\nprintf (\"Derived key (hex): %s\\n\", bin2hex($key));\n\n\n\n\n\nPerformance of the scrypt implementation\n\n\nThe aim of the scrypt algorithm is to generate a secure derived key that\nprevents brute force attacks.  Just like the other derivation functions, the\nmore time (and memory) spent executing the algorithm, the more secure the\nderived key will be. Unfortunately a pure PHP implementation of the scrypt\nalgorithm is very slow compared with the C implementation (this is always\ntrue, if you compare execution time of C with PHP). If you want use a faster\nscrypt algorithm, we suggest installing the PECL \nscrypt\nextension\n. The \nScrypt\n adapter we\nprovide is able to recognize if the PECL extension is loaded and will use it\ninstead of the pure PHP implementation.\n\n\n\n\nFootnotes\n\n\n\n\n1\n See Colin Percival's \nslides on scrypt from BSDCan'09\n.",
            "title": "Key Derivation"
        },
        {
            "location": "/key-derivation/#key-derivation-function",
            "text": "In cryptography, a key derivation function (or KDF) derives one or more secret\nkeys from a secret value such as a master key, or known information \u2014 such\nas a password or passphrase \u2014 using a pseudo-random function. For\ninstance, a KDF function can be used to generate encryption or authentication\nkeys from a user password.  Zend\\Crypt\\Key\\Derivation  implements a key\nderivation function using specific adapters.  User passwords are not really suitable to be used as keys in cryptographic\nalgorithms, since users normally choose keys they can write with a keyboard. These\npasswords use only 6 to 7 bits per character (or less). It is highly recommended\nalways to use a KDF function to transform a user's password in a cryptographic\nkey.  The output of the following key derivation functions is a binary string. If you\nneed to store the value in a database or a different persistent storage, we\nsuggest converting it to Base64 format, using the base64_encode()  function,\nor to hex format, using the bin2hex()  function.",
            "title": "Key derivation function"
        },
        {
            "location": "/key-derivation/#pbkdf2-adapter",
            "text": "Pbkdf2  is a KDF that applies a\npseudorandom function, such as a cryptographic hash, to the input password or\npassphrase along with a salt value and repeats the process many times to produce\na derived key, which can then be used as a cryptographic key in subsequent\noperations. The added computational work makes password cracking much more\ndifficult, and is known as  key\nstretching .  In the example below we demonstrate typical usage of the  Pbkdf2  adapter.  use Zend\\Crypt\\Key\\Derivation\\Pbkdf2;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Pbkdf2::calc('sha256', $pass, $salt, 10000, 32);\n\nprintf (\"Original password: %s\\n\", $pass);\nprintf (\"Derived key (hex): %s\\n\", bin2hex($key));  The  Pbkdf2  adapter takes the password ( $pass ) and generates a binary key of\n32 bytes. The syntax is  calc($hash, $pass, $salt, $iterations, $length)  where $hash  is the name of the hash function to use,  $pass  is the password, $salt  is a pseudo random value,  $iterations  is the number of iterations of\nthe algorithm, and  $length  is the size of the key to be generated. We use the Rand::getBytes()  function from the class  Zend\\Math\\Rand  to generate a random\nstring of 32 bytes for the salt, using a strong generator (the  true  value\nmeans the usage of a cryptographically strong generator).  The number of iterations is a very important parameter for the security of the\nalgorithm; bigger values guarantee more security. There is no fixed value for\nthe parameter because the number of iterations depends on CPU power. You should\nalways choose a number of iterations that prevents brute force attacks.",
            "title": "Pbkdf2 adapter"
        },
        {
            "location": "/key-derivation/#salteds2k-adapter",
            "text": "The  SaltedS2k  algorithm uses a hash\nfunction and a salt to generate a key based on a user's password. This algorithm\ndoesn't use a parameter to specify the number of iterations, and for that reason\nit's considered less secure compared to Pbkdf2. We suggest using the SaltedS2k\nalgorithm only if you really need it (for instance, due to hardware\nlimitations).  The following demonstrates usage of the  SaltedS2k  adapter to generate a 32\nbyte key.  use Zend\\Crypt\\Key\\Derivation\\SaltedS2k;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = SaltedS2k::calc('sha256', $pass, $salt, 32);\n\nprintf (\"Original password: %s\\n\", $pass);\nprintf (\"Derived key (hex): %s\\n\", bin2hex($key));",
            "title": "SaltedS2k adapter"
        },
        {
            "location": "/key-derivation/#scrypt-adapter",
            "text": "The  scrypt  algorithm uses the  Salsa20/8\ncore  algorithm and Pbkdf2-SHA256 to generate a\nkey based on a user's password. This algorithm has been designed to be more\nsecure against hardware brute-force attacks than alternative functions such as Pbkdf2  or bcrypt .  The scrypt algorithm is based on the idea of memory-hard algorithms and\nsequential memory-hard functions. A memory-hard algorithm is an algorithm which\nasymptotically uses almost as many memory locations as it uses\noperations 1 . A natural way to reduce the advantage\nprovided by an attacker\u2019s ability to construct highly parallel circuits is to\nincrease the size of a single key derivation circuit \u2014 if a circuit is twice as\nlarge, only half as many copies can be placed on a given area of silicon \u2014 while\nstill operating within the resources available to software implementations,\nincluding a powerful CPU and large amounts of RAM.   \"From a test executed on modern (2009) hardware, if 5 seconds are spent\ncomputing a derived key, the cost of a hardware brute-force attack against\nscrypt is roughly 4000 times greater than the cost of a similar attack against\nbcrypt (to find the same password), and 20000 times greater than a similar\nattack against Pbkdf2.\"  \u2014  Colin Percival  (author of the scrypt algorithm)   This algorithm uses 4 parameters to generate a key of 32 bytes:   salt , a random string;  N , the CPU cost;  r , the memory cost;  p , the parallelization cost.   Following is a usage example for the  Scrypt  adapter:  use Zend\\Crypt\\Key\\Derivation\\Scrypt;\nuse Zend\\Math\\Rand;\n\n$pass = 'password';\n$salt = Rand::getBytes(32, true);\n$key  = Scrypt::calc($pass, $salt, 2048, 2, 1, 32);\n\nprintf (\"Original password: %s\\n\", $pass);\nprintf (\"Derived key (hex): %s\\n\", bin2hex($key));",
            "title": "Scrypt adapter"
        },
        {
            "location": "/key-derivation/#performance-of-the-scrypt-implementation",
            "text": "The aim of the scrypt algorithm is to generate a secure derived key that\nprevents brute force attacks.  Just like the other derivation functions, the\nmore time (and memory) spent executing the algorithm, the more secure the\nderived key will be. Unfortunately a pure PHP implementation of the scrypt\nalgorithm is very slow compared with the C implementation (this is always\ntrue, if you compare execution time of C with PHP). If you want use a faster\nscrypt algorithm, we suggest installing the PECL  scrypt\nextension . The  Scrypt  adapter we\nprovide is able to recognize if the PECL extension is loaded and will use it\ninstead of the pure PHP implementation.",
            "title": "Performance of the scrypt implementation"
        },
        {
            "location": "/key-derivation/#footnotes",
            "text": "1  See Colin Percival's  slides on scrypt from BSDCan'09 .",
            "title": "Footnotes"
        },
        {
            "location": "/password/",
            "text": "Password\n\n\nIn the \nZend\\Crypt\\Password\n namespace you will find a number of password\nformats supported by the zend-crypt component. These currently include:\n\n\n\n\nbcrypt\n\n\nApache (htpasswd)\n\n\n\n\nIf you need to choose a password format to store a user\u2019s password, we suggest\nusing the bcrypt algorithm, as it is considered secure against brute forcing\nattacks (see details below).\n\n\nBcrypt\n\n\nThe \nbcrypt\n algorithm is a hashing algorithm\nthat is widely used and recommended by the security community to store user\npasswords in a secure way.\n\n\nClassic hashing mechanisms like MD5 or SHA, with or without a salt value, are\nnot considered secure anymore (\nread this post to understand\nwhy\n).\n\n\nThe security of bcrypt is related to the speed of the algorithm. Bcrypt is very\nslow, and can take up to a second to generate a hash value. That means a brute\nforce attack is impossible to execute, due to the amount of time that required.\n\n\nBcrypt uses a \ncost\n parameter that specify the number of cycles to use in the\nalgorithm. Increasing this number the algorithm will spend more time to generate\nthe hash output. The cost parameter is represented by an integer value between 4\nto 31. The default cost value of \nZend\\Crypt\\Password\\Bcrypt\n is 10, requiring\naround 0.07s using a CPU Intel i5 at 3.3Ghz (the cost parameter is a relative\nvalue according to the speed of the CPU used). Starting with version 2.3.0, we\nchanged the default value of the cost parameter from 14 to 10, in an effort to\nreduce denial-of-service attacks due to too high computational time\nrequirements. (Read this article on \naggressive password stretching\n\nfor more information).\n\n\nIf you want to change the cost parameter of the bcrypt algorithm, you can use\nthe \nsetCost()\n method. Please note, if you change the cost parameter, the\nresulting hash will be different. However, This will not affect the verification\nprocess of the algorithm, therefore not breaking the password hashes you already\nhave stored; Bcrypt reads the cost parameter from the hash value during password\nauthentication. All of the parts needed to verify the hash are present in the\nhash itself,, separated with \n$\n\u2019s; first the algorithm, then the cost, the\nsalt, and then finally the hash.\n\n\nThe example below demonstrates using the bcrypt algorithm to store a user\u2019s password:\n\n\nuse Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = $bcrypt->create('user password');\n\n\n\nThe output of the \ncreate()\n method is the hash of the password. This value can\nthen be stored in a repository like a database (the output is a string of 60\nbytes).\n\n\n\n\nBcrypt truncates input > 72 bytes\n\n\nThe input string of the bcrypt algorithm is limited to 72 bytes. If you use a\nstring with a length more than this limit, bcrypt will consider only the first\n72 bytes. If you need to use a longer string, you should pre-hash it.\nWe provide the class \nZend\\Crypt\\Password\\BcryptSha\n for performing\npassword pre-hashing of hash input > 72 bytes.\n\n\n\n\nTo verify if a given password is valid against a bcrypt value you can use the\n\nverify()\n method. The example below demonstrates verification:\n\n\nuse Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = 'the stored bcrypt value';\n$password = 'the password to check';\n\nif ($bcrypt->verify($password, $securePass)) {\n    echo \"The password is correct! \\n\";\n} else {\n    echo \"The password is NOT correct.\\n\";\n}\n\n\n\nBcrypt also uses a salt value to improve the randomness of the algorithm.\nBy default, \nZend\\Crypt\\Password\\Bcrypt\n generates a random salt for\neach hash. If you want to specify a preselected salt you can use the \nsetSalt()\n\nmethod.\n\n\nWe also provide a \ngetSalt()\n method to retrieve the salt specified by the user.\nThe salt and the cost parameter can be also specified during the constructor of\nthe class, as demonstrated below:\n\n\nuse Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt([\n    'salt' => 'random value',\n    'cost' => 11\n]);\n\n\n\n\n\nVersion 3.0\n\n\nStarting with version 3.0, we now use the \npassword_hash()\n\nand `\npassword_verify()\n functions introduced\nin PHP 5.5 to generate bcrypt hash values. We provide backwards\ncompatibility tests to ensure that any hashes generated with version 2\nreleases can still be validated under version 3.\n\n\n\n\nApache\n\n\nZend\\Crypt\\Password\\Apache\n supports all the password formats used by\n\nApache\n\n(htpasswd). These formats include:\n\n\n\n\nCRYPT, which uses the traditional Unix crypt(3) function with a\n  randomly-generated 32-bit salt (only 12 bits used) and the first 8 characters\n  of the password;\n\n\nSHA1, \u201c{SHA}\u201d + Base64-encoded SHA-1 digest of the password;\n\n\nMD5, \u201c$apr1$\u201d + the result of an Apache-specific algorithm using an iterated\n  (1,000 times) MD5 digest of various combinations of a random 32-bit salt and\n  the password.\n\n\nDigest, the MD5 hash of the string \nuser:realm:password\n as a 32-character\n  string of hexadecimal digits. \nrealm\n is the Authorization Realm argument to\n  the AuthName directive in \nhttpd.conf\n.\n\n\n\n\nIn order to specify the format of the Apache\u2019s password, use the \nsetFormat()\n\nmethod. An example with all the formats usage is demonstrated below:\n\n\nuse Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache();\n\n$apache->setFormat('crypt');\nprintf (\"CRYPT output: %s\\n\", $apache->create('password'));\n\n$apache->setFormat('sha1');\nprintf (\"SHA1 output: %s\\n\", $apache->create('password'));\n\n$apache->setFormat('md5');\nprintf (\"MD5 output: %s\\n\", $apache->create('password'));\n\n$apache->setFormat('digest');\n$apache->setUserName('enrico');\n$apache->setAuthName('test');\nprintf (\"Digest output: %s\\n\", $apache->create('password'));\n\n\n\nYou can also specify the format of the password during the constructor of the class:\n\n\nuse Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache([\n    'format' => 'md5'\n]);\n\n\n\nOther possible parameters to pass in the constructor are \nusername\n and \nauthname\n,\nfor the digest format.",
            "title": "Passwords"
        },
        {
            "location": "/password/#password",
            "text": "In the  Zend\\Crypt\\Password  namespace you will find a number of password\nformats supported by the zend-crypt component. These currently include:   bcrypt  Apache (htpasswd)   If you need to choose a password format to store a user\u2019s password, we suggest\nusing the bcrypt algorithm, as it is considered secure against brute forcing\nattacks (see details below).",
            "title": "Password"
        },
        {
            "location": "/password/#bcrypt",
            "text": "The  bcrypt  algorithm is a hashing algorithm\nthat is widely used and recommended by the security community to store user\npasswords in a secure way.  Classic hashing mechanisms like MD5 or SHA, with or without a salt value, are\nnot considered secure anymore ( read this post to understand\nwhy ).  The security of bcrypt is related to the speed of the algorithm. Bcrypt is very\nslow, and can take up to a second to generate a hash value. That means a brute\nforce attack is impossible to execute, due to the amount of time that required.  Bcrypt uses a  cost  parameter that specify the number of cycles to use in the\nalgorithm. Increasing this number the algorithm will spend more time to generate\nthe hash output. The cost parameter is represented by an integer value between 4\nto 31. The default cost value of  Zend\\Crypt\\Password\\Bcrypt  is 10, requiring\naround 0.07s using a CPU Intel i5 at 3.3Ghz (the cost parameter is a relative\nvalue according to the speed of the CPU used). Starting with version 2.3.0, we\nchanged the default value of the cost parameter from 14 to 10, in an effort to\nreduce denial-of-service attacks due to too high computational time\nrequirements. (Read this article on  aggressive password stretching \nfor more information).  If you want to change the cost parameter of the bcrypt algorithm, you can use\nthe  setCost()  method. Please note, if you change the cost parameter, the\nresulting hash will be different. However, This will not affect the verification\nprocess of the algorithm, therefore not breaking the password hashes you already\nhave stored; Bcrypt reads the cost parameter from the hash value during password\nauthentication. All of the parts needed to verify the hash are present in the\nhash itself,, separated with  $ \u2019s; first the algorithm, then the cost, the\nsalt, and then finally the hash.  The example below demonstrates using the bcrypt algorithm to store a user\u2019s password:  use Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = $bcrypt->create('user password');  The output of the  create()  method is the hash of the password. This value can\nthen be stored in a repository like a database (the output is a string of 60\nbytes).",
            "title": "Bcrypt"
        },
        {
            "location": "/password/#bcrypt-truncates-input-72-bytes",
            "text": "The input string of the bcrypt algorithm is limited to 72 bytes. If you use a\nstring with a length more than this limit, bcrypt will consider only the first\n72 bytes. If you need to use a longer string, you should pre-hash it.\nWe provide the class  Zend\\Crypt\\Password\\BcryptSha  for performing\npassword pre-hashing of hash input > 72 bytes.   To verify if a given password is valid against a bcrypt value you can use the verify()  method. The example below demonstrates verification:  use Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt();\n$securePass = 'the stored bcrypt value';\n$password = 'the password to check';\n\nif ($bcrypt->verify($password, $securePass)) {\n    echo \"The password is correct! \\n\";\n} else {\n    echo \"The password is NOT correct.\\n\";\n}  Bcrypt also uses a salt value to improve the randomness of the algorithm.\nBy default,  Zend\\Crypt\\Password\\Bcrypt  generates a random salt for\neach hash. If you want to specify a preselected salt you can use the  setSalt() \nmethod.  We also provide a  getSalt()  method to retrieve the salt specified by the user.\nThe salt and the cost parameter can be also specified during the constructor of\nthe class, as demonstrated below:  use Zend\\Crypt\\Password\\Bcrypt;\n\n$bcrypt = new Bcrypt([\n    'salt' => 'random value',\n    'cost' => 11\n]);",
            "title": "Bcrypt truncates input &gt; 72 bytes"
        },
        {
            "location": "/password/#version-30",
            "text": "Starting with version 3.0, we now use the  password_hash() \nand ` password_verify()  functions introduced\nin PHP 5.5 to generate bcrypt hash values. We provide backwards\ncompatibility tests to ensure that any hashes generated with version 2\nreleases can still be validated under version 3.",
            "title": "Version 3.0"
        },
        {
            "location": "/password/#apache",
            "text": "Zend\\Crypt\\Password\\Apache  supports all the password formats used by Apache \n(htpasswd). These formats include:   CRYPT, which uses the traditional Unix crypt(3) function with a\n  randomly-generated 32-bit salt (only 12 bits used) and the first 8 characters\n  of the password;  SHA1, \u201c{SHA}\u201d + Base64-encoded SHA-1 digest of the password;  MD5, \u201c$apr1$\u201d + the result of an Apache-specific algorithm using an iterated\n  (1,000 times) MD5 digest of various combinations of a random 32-bit salt and\n  the password.  Digest, the MD5 hash of the string  user:realm:password  as a 32-character\n  string of hexadecimal digits.  realm  is the Authorization Realm argument to\n  the AuthName directive in  httpd.conf .   In order to specify the format of the Apache\u2019s password, use the  setFormat() \nmethod. An example with all the formats usage is demonstrated below:  use Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache();\n\n$apache->setFormat('crypt');\nprintf (\"CRYPT output: %s\\n\", $apache->create('password'));\n\n$apache->setFormat('sha1');\nprintf (\"SHA1 output: %s\\n\", $apache->create('password'));\n\n$apache->setFormat('md5');\nprintf (\"MD5 output: %s\\n\", $apache->create('password'));\n\n$apache->setFormat('digest');\n$apache->setUserName('enrico');\n$apache->setAuthName('test');\nprintf (\"Digest output: %s\\n\", $apache->create('password'));  You can also specify the format of the password during the constructor of the class:  use Zend\\Crypt\\Password\\Apache;\n\n$apache = new Apache([\n    'format' => 'md5'\n]);  Other possible parameters to pass in the constructor are  username  and  authname ,\nfor the digest format.",
            "title": "Apache"
        },
        {
            "location": "/public-key/",
            "text": "Public key cryptography\n\n\nPublic-key cryptography refers to a cryptographic system requiring two separate\nkeys, one of which is secret and one of which is public. Although different, the\ntwo parts of the key pair are mathematically linked. One key locks or encrypts\nthe plaintext, and the other unlocks or decrypts the cyphertext. Neither key can\nperform both functions. One of these keys is published or public, while the\nother is kept private.\n\n\nIn zend-crypt, we implement two public key algorithms:\n\n\n\n\nDiffie-Hellman\n\n  key exchange, and\n\n\nRSA\n.\n\n\n\n\nDiffie-Hellman\n\n\nThe Diffie-Hellman algorithm is a specific method of exchanging cryptographic\nkeys. It is one of the earliest practical examples of key exchange implemented\nwithin the field of cryptography. The Diffie\u2013Hellman key exchange method allows\ntwo parties that have no prior knowledge of each other to jointly establish a\nshared secret key over an insecure communications channel. This key can then be\nused to encrypt subsequent communications using a symmetric key cipher.\n\n\nThe diagram of operation of the Diffie-Hellman algorithm can be defined by the\nfollowing picture (taken from the \nDiffie-Hellman\n\nWikipedia page):\n\n\n\n\nThe schema's colors represent the parameters of the algorithm.\n\n\nBelow is an example demonstrating usage of \nZend\\Crypt\\PublicKey\\DiffieHellman\n:\n\n\nuse Zend\\Crypt\\PublicKey\\DiffieHellman;\n\n$aliceOptions = [\n    'prime' => '155172898181473697471232257763715539915724801966915404479707795314057629378541917580651227'\n        . '423698188993727816152646631438561595825688188889951272158842675419950341258706556549803580'\n        . '104870537681476726513255747040765857479291291572334510643245094715007229621094194349783925'\n        . '984760375594985848253359305585439638443',\n    'generator'=> '2',\n    'private'  => '992093140665725952364085695919679885571412495614942674862518080355353963322786201435363176'\n        . '813127128916726230726309951803243888416814918577455156967890911274095150092503589658166661'\n        . '463420498381785213791321533481399080168191962194483101070726325157493390557981225386151351'\n        . '04828702523796951800575031871051678091',\n];\n\n$bobOptions   = [\n    'prime'    => $aliceOptions['prime'],\n    'generator'=> '2',\n    'private'  => '334117357926395586257336357178925636125481806504021611510774783148414637079488997861035889'\n        . '123256347304105519467727528801778689728169635518217403867000760342134081539246925625431179'\n        . '634647331566005454845108330724270034742070646507148310833044977371603820970833568760781462'\n        . '31616972608703322302585471319261275664',\n);\n\n$alice = new DiffieHellman(\n    $aliceOptions['prime'],\n    $aliceOptions['generator'],\n    $aliceOptions['private']\n);\n$bob = new DiffieHellman(\n    $bobOptions['prime'],\n    $bobOptions['generator'],\n    $bobOptions['private']\n);\n\n$alice->generateKeys();\n$bob->generateKeys();\n\n$aliceSecretKey = $alice->computeSecretKey(\n    $bob->getPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\n$bobSecretKey = $bob->computeSecretKey(\n    $alice->getPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\nif ($aliceSecretKey !== $bobSecretKey) {\n    echo \"ERROR!\\n\";\n} else {\n    printf(\"The secret key is: %s\\n\", base64_encode($aliceSecretKey));\n}\n\n\n\nThe parameters of the Diffie-Hellman class are:\n\n\n\n\na prime number (p),\n\n\na generator (g) that is a primitive root mod p, and\n\n\na private integer number.\n\n\n\n\nThe security of the Diffie-Hellman exchange algorithm is related to the choice\nof these parameters. To know how to choose secure numbers you can read the\n\nRFC 3526\n document.\n\n\n\n\nOpenssl\n\n\nThe \nZend\\Crypt\\PublicKey\\DiffieHellman\n class by default uses the\n\nOpenSSL\n extension to generate the\nparameters. If you don't want to use the OpenSSL library, call\n\nDiffieHelmman::useOpensslExtension(false)\n.\n\n\n\n\nRSA\n\n\nRSA is an algorithm for public-key cryptography that is based on the presumed\ndifficulty of factoring large integers, known as the \nfactoring\nproblem\n. A user of RSA creates\nand then publishes the product of two large prime numbers, along with an\nauxiliary value, as their public key. The prime factors must be kept secret.\nAnyone can use the public key to encrypt a message, but with currently published\nmethods, if the public key is large enough, only someone with knowledge of the\nprime factors can feasibly decode the message. Whether breaking RSA encryption\nis as hard as factoring is an open question.\n\n\nThe RSA algorithm can be used to encrypt/decrypt messages, and also to provide\nauthenticity and integrity by generating a digital signature of a message.\n\n\nSuppose that Alice wants to send an encrypted message to Bob. Alice must use the\npublic key of Bob to encrypt the message. Bob can decrypt the message using his\nprivate key. Because Bob is the only one that can access his private key,\nhe is the only one that can decrypt the message. If Alice wants to provide\nauthenticity and integrity of a message to Bob she can use her private key to\nsign the message. Bob can check the correctness of the digital signature using\nthe public key of Alice. Alice can provide encryption, authenticity, and\nintegrity of a message to Bob using the previous schemas in sequence, applying\nthe encryption first and the digital signature after.\n\n\nBelow are examples of usage of the \nZend\\Crypt\\PublicKey\\Rsa\n class in order to:\n\n\n\n\ngenerate a public key and a private key;\n\n\nencrypt/decrypt a string;\n\n\ngenerate a digital signature of a file.\n\n\n\n\nGenerate a public key and a private key\n\n\nIn order to generate a public and private key, use the following code:\n\n\nuse Zend\\Crypt\\PublicKey\\RsaOptions;\n\n$rsaOptions = new RsaOptions([\n    'pass_phrase' => 'test'\n]);\n\n$rsaOptions->generateKeys([\n    'private_key_bits' => 2048,\n]);\n\nfile_put_contents('private_key.pem', $rsaOptions->getPrivateKey());\nfile_put_contents('public_key.pub', $rsaOptions->getPublicKey());\n\n\n\nThis example generates a 2048-bit public and private key, storing the keys in two separate files,\n\nprivate_key.pem\n for the private key and \npublic_key.pub\n for the public key. You can also\ngenerate the public and private key using OpenSSL from the command line (Unix style syntax):\n\n\n$ ssh-keygen -t rsa\n\n\n\nEncrypt and decrypt a string\n\n\nBelow is an example demonstrating encryption and decryption of a string using\nthe RSA algorithm. You can encrypt only small strings. The maximum size of\nencryption is given by the length of the public/private key - 88 bits. For\ninstance, if we use a size of 2048 bit you can encrypt a string with a maximum\nsize of 1960 bit (245 characters). This limitation is related to the OpenSSL\nimplementation for a security reason related to the nature of the RSA algorithm.\n\n\nThe normal application of public key encryption algorithm is to store a key or a\nhash of the data you want to encrypt or sign. A hash is typically 128-256 bits\n(the PHP \nsha1()\n function returns a 160 bit hash). An AES encryption key is 128\nto 256 bits. Either will comfortably fit inside a single RSA encryption.\n\n\nuse Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'public_key'    => 'public_key.pub',\n    'private_key'   => 'private_key.pem',\n    'pass_phrase'   => 'test',\n    'binary_output' => false,\n]);\n\n$text = 'This is the message to encrypt';\n\n$encrypt = $rsa->encrypt($text);\nprintf(\"Encrypted message:\\n%s\\n\", $encrypt);\n\n$decrypt = $rsa->decrypt($encrypt);\n\nif ($text !== $decrypt) {\n    echo \"ERROR\\n\";\n} else {\n    echo \"Encryption and decryption performed successfully!\\n\";\n}\n\n\n\nGenerate a digital signature of a file\n\n\nBelow is an example demonstrating generation of a digital file signature.\n\n\nuse Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'private_key'   => 'path/to/private_key',\n    'pass_phrase'   => 'passphrase of the private key',\n    'binary_output' => false,\n]);\n\n$file = file_get_contents('path/file/to/sign');\n\n$signature = $rsa->sign($file, $rsa->getOptions()->getPrivateKey());\n$verify    = $rsa->verify($file, $signature, $rsa->getOptions()->getPublicKey());\n\nif ($verify) {\n    echo \"The signature is OK\\n\";\n    file_put_contents($filename . '.sig', $signature);\n    echo \"Signature save in $filename.sig\\n\";\n} else {\n     echo \"The signature is not valid!\\n\";\n}\n\n\n\nIn this example, we used the Base64 format to encode the digital signature of the file\n(\nbinary_output\n is false).\n\n\n\n\nOpenssl\n\n\nThe implementation of the \nZend\\Crypt\\PublicKey\\Rsa\n algorithm uses PHP's OpenSSL extension.",
            "title": "Public Key Cryptography"
        },
        {
            "location": "/public-key/#public-key-cryptography",
            "text": "Public-key cryptography refers to a cryptographic system requiring two separate\nkeys, one of which is secret and one of which is public. Although different, the\ntwo parts of the key pair are mathematically linked. One key locks or encrypts\nthe plaintext, and the other unlocks or decrypts the cyphertext. Neither key can\nperform both functions. One of these keys is published or public, while the\nother is kept private.  In zend-crypt, we implement two public key algorithms:   Diffie-Hellman \n  key exchange, and  RSA .",
            "title": "Public key cryptography"
        },
        {
            "location": "/public-key/#diffie-hellman",
            "text": "The Diffie-Hellman algorithm is a specific method of exchanging cryptographic\nkeys. It is one of the earliest practical examples of key exchange implemented\nwithin the field of cryptography. The Diffie\u2013Hellman key exchange method allows\ntwo parties that have no prior knowledge of each other to jointly establish a\nshared secret key over an insecure communications channel. This key can then be\nused to encrypt subsequent communications using a symmetric key cipher.  The diagram of operation of the Diffie-Hellman algorithm can be defined by the\nfollowing picture (taken from the  Diffie-Hellman \nWikipedia page):   The schema's colors represent the parameters of the algorithm.  Below is an example demonstrating usage of  Zend\\Crypt\\PublicKey\\DiffieHellman :  use Zend\\Crypt\\PublicKey\\DiffieHellman;\n\n$aliceOptions = [\n    'prime' => '155172898181473697471232257763715539915724801966915404479707795314057629378541917580651227'\n        . '423698188993727816152646631438561595825688188889951272158842675419950341258706556549803580'\n        . '104870537681476726513255747040765857479291291572334510643245094715007229621094194349783925'\n        . '984760375594985848253359305585439638443',\n    'generator'=> '2',\n    'private'  => '992093140665725952364085695919679885571412495614942674862518080355353963322786201435363176'\n        . '813127128916726230726309951803243888416814918577455156967890911274095150092503589658166661'\n        . '463420498381785213791321533481399080168191962194483101070726325157493390557981225386151351'\n        . '04828702523796951800575031871051678091',\n];\n\n$bobOptions   = [\n    'prime'    => $aliceOptions['prime'],\n    'generator'=> '2',\n    'private'  => '334117357926395586257336357178925636125481806504021611510774783148414637079488997861035889'\n        . '123256347304105519467727528801778689728169635518217403867000760342134081539246925625431179'\n        . '634647331566005454845108330724270034742070646507148310833044977371603820970833568760781462'\n        . '31616972608703322302585471319261275664',\n);\n\n$alice = new DiffieHellman(\n    $aliceOptions['prime'],\n    $aliceOptions['generator'],\n    $aliceOptions['private']\n);\n$bob = new DiffieHellman(\n    $bobOptions['prime'],\n    $bobOptions['generator'],\n    $bobOptions['private']\n);\n\n$alice->generateKeys();\n$bob->generateKeys();\n\n$aliceSecretKey = $alice->computeSecretKey(\n    $bob->getPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\n$bobSecretKey = $bob->computeSecretKey(\n    $alice->getPublicKey(DiffieHellman::FORMAT_BINARY),\n    DiffieHellman::FORMAT_BINARY,\n    DiffieHellman::FORMAT_BINARY\n);\n\nif ($aliceSecretKey !== $bobSecretKey) {\n    echo \"ERROR!\\n\";\n} else {\n    printf(\"The secret key is: %s\\n\", base64_encode($aliceSecretKey));\n}  The parameters of the Diffie-Hellman class are:   a prime number (p),  a generator (g) that is a primitive root mod p, and  a private integer number.   The security of the Diffie-Hellman exchange algorithm is related to the choice\nof these parameters. To know how to choose secure numbers you can read the RFC 3526  document.",
            "title": "Diffie-Hellman"
        },
        {
            "location": "/public-key/#openssl",
            "text": "The  Zend\\Crypt\\PublicKey\\DiffieHellman  class by default uses the OpenSSL  extension to generate the\nparameters. If you don't want to use the OpenSSL library, call DiffieHelmman::useOpensslExtension(false) .",
            "title": "Openssl"
        },
        {
            "location": "/public-key/#rsa",
            "text": "RSA is an algorithm for public-key cryptography that is based on the presumed\ndifficulty of factoring large integers, known as the  factoring\nproblem . A user of RSA creates\nand then publishes the product of two large prime numbers, along with an\nauxiliary value, as their public key. The prime factors must be kept secret.\nAnyone can use the public key to encrypt a message, but with currently published\nmethods, if the public key is large enough, only someone with knowledge of the\nprime factors can feasibly decode the message. Whether breaking RSA encryption\nis as hard as factoring is an open question.  The RSA algorithm can be used to encrypt/decrypt messages, and also to provide\nauthenticity and integrity by generating a digital signature of a message.  Suppose that Alice wants to send an encrypted message to Bob. Alice must use the\npublic key of Bob to encrypt the message. Bob can decrypt the message using his\nprivate key. Because Bob is the only one that can access his private key,\nhe is the only one that can decrypt the message. If Alice wants to provide\nauthenticity and integrity of a message to Bob she can use her private key to\nsign the message. Bob can check the correctness of the digital signature using\nthe public key of Alice. Alice can provide encryption, authenticity, and\nintegrity of a message to Bob using the previous schemas in sequence, applying\nthe encryption first and the digital signature after.  Below are examples of usage of the  Zend\\Crypt\\PublicKey\\Rsa  class in order to:   generate a public key and a private key;  encrypt/decrypt a string;  generate a digital signature of a file.",
            "title": "RSA"
        },
        {
            "location": "/public-key/#generate-a-public-key-and-a-private-key",
            "text": "In order to generate a public and private key, use the following code:  use Zend\\Crypt\\PublicKey\\RsaOptions;\n\n$rsaOptions = new RsaOptions([\n    'pass_phrase' => 'test'\n]);\n\n$rsaOptions->generateKeys([\n    'private_key_bits' => 2048,\n]);\n\nfile_put_contents('private_key.pem', $rsaOptions->getPrivateKey());\nfile_put_contents('public_key.pub', $rsaOptions->getPublicKey());  This example generates a 2048-bit public and private key, storing the keys in two separate files, private_key.pem  for the private key and  public_key.pub  for the public key. You can also\ngenerate the public and private key using OpenSSL from the command line (Unix style syntax):  $ ssh-keygen -t rsa",
            "title": "Generate a public key and a private key"
        },
        {
            "location": "/public-key/#encrypt-and-decrypt-a-string",
            "text": "Below is an example demonstrating encryption and decryption of a string using\nthe RSA algorithm. You can encrypt only small strings. The maximum size of\nencryption is given by the length of the public/private key - 88 bits. For\ninstance, if we use a size of 2048 bit you can encrypt a string with a maximum\nsize of 1960 bit (245 characters). This limitation is related to the OpenSSL\nimplementation for a security reason related to the nature of the RSA algorithm.  The normal application of public key encryption algorithm is to store a key or a\nhash of the data you want to encrypt or sign. A hash is typically 128-256 bits\n(the PHP  sha1()  function returns a 160 bit hash). An AES encryption key is 128\nto 256 bits. Either will comfortably fit inside a single RSA encryption.  use Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'public_key'    => 'public_key.pub',\n    'private_key'   => 'private_key.pem',\n    'pass_phrase'   => 'test',\n    'binary_output' => false,\n]);\n\n$text = 'This is the message to encrypt';\n\n$encrypt = $rsa->encrypt($text);\nprintf(\"Encrypted message:\\n%s\\n\", $encrypt);\n\n$decrypt = $rsa->decrypt($encrypt);\n\nif ($text !== $decrypt) {\n    echo \"ERROR\\n\";\n} else {\n    echo \"Encryption and decryption performed successfully!\\n\";\n}",
            "title": "Encrypt and decrypt a string"
        },
        {
            "location": "/public-key/#generate-a-digital-signature-of-a-file",
            "text": "Below is an example demonstrating generation of a digital file signature.  use Zend\\Crypt\\PublicKey\\Rsa;\n\n$rsa = Rsa::factory([\n    'private_key'   => 'path/to/private_key',\n    'pass_phrase'   => 'passphrase of the private key',\n    'binary_output' => false,\n]);\n\n$file = file_get_contents('path/file/to/sign');\n\n$signature = $rsa->sign($file, $rsa->getOptions()->getPrivateKey());\n$verify    = $rsa->verify($file, $signature, $rsa->getOptions()->getPublicKey());\n\nif ($verify) {\n    echo \"The signature is OK\\n\";\n    file_put_contents($filename . '.sig', $signature);\n    echo \"Signature save in $filename.sig\\n\";\n} else {\n     echo \"The signature is not valid!\\n\";\n}  In this example, we used the Base64 format to encode the digital signature of the file\n( binary_output  is false).",
            "title": "Generate a digital signature of a file"
        },
        {
            "location": "/public-key/#openssl_1",
            "text": "The implementation of the  Zend\\Crypt\\PublicKey\\Rsa  algorithm uses PHP's OpenSSL extension.",
            "title": "Openssl"
        }
    ]
}